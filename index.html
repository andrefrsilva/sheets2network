<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"></meta>
  <title>Sheets2Network</title>

  <!-- Vis.js -->
  <script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>
  <!-- XLSX for Excel -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
  <!-- Chart.js for Analytics -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Basic layout and styling */
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      margin: 0; 
      padding: 0;
      background-color: #f9f9f9;
      color: #333;
    }
    .content-container {
      width: 95%;
      margin: 10px auto;
      max-width: 1200px;
    }
    h2, h3 {
      font-weight: 600;
    }
    p { line-height: 1.4; }
    .separator a img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 1em auto;
    }

    button {
      cursor: pointer;
      border-radius: 4px;
      border: none;
      padding: 6px 12px;
      font-size: 14px;
      transition: background-color 0.2s, opacity 0.2s;
    }
    button:hover {
      opacity: 0.85;
    }
    .button {
      background-color: #4CAF50;
      color: #fff;
      margin: 2px 3px;
    }

    /* Toggling buttons (Groups / Color Grading) */
    .toggleBtn {
      background-color: #4CAF50;
      color: white;
      margin-left: 8px;
      padding: 5px 10px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .toggleBtn.off {
      background-color: #ccc;
      color: #666;
    }

    /* The Vis Network container */
    #mynetwork {
      width: 100%;
      height: 600px;
      border: 1px solid lightgray;
      background-color: white;
      position: relative;
      margin: 10px 0;
    }

    /* Error panel (small font, faded red boxes, one error per line) */
    #errorPanel {
      font-size: 12px;
      margin: 8px 0 6px 0;
    }
    .error-line {
      background: rgba(229, 57, 53, 0.10);
      border-left: 3px solid #e53935;
      padding: 6px 8px;
      margin: 4px 0;
      border-radius: 4px;
      line-height: 1.3;
      word-break: break-word;
    }

    /* Watermark */
    #watermark {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: gray;
      opacity: 0.5;
      font-size: 12px;
      z-index: 1000;
    }
    #watermark a {
      color: gray; 
      text-decoration: none;
    }

    /* Analytics charts */
    #degreeChart, #clusteringChart {
      display: none;
      height: 400px;
      margin-top: 20px;
      background-color: #fff;
      border: 1px solid #ccc;
    }

    /* Kanban board styles */
    #kanbanContainer {
      width: 100%;
      margin-top: 30px;
    }
    .kanban-board {
      display: flex;
      flex-wrap: wrap; 
      gap: 15px;
    }
    .kanban-column {
      min-width: 220px;
      flex: 1 1 auto;
      background-color: #fafafa;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 10px;
      margin-bottom: 10px;
      position: relative;
    }
    .kanban-column-title {
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .kanban-card {
      margin: 6px 0;
      padding: 6px 8px;
      border-radius: 4px;
      background-color: #eee;
      color: #fff; /* White text on the card */
      cursor: pointer;
      font-size: 13px;
      transition: transform 0.2s;
      position: relative;
    }
    .kanban-card:hover {
      transform: scale(1.01);
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    /* An info icon if there's a comment */
    .kanban-info-icon {
      position: absolute;
      right: 6px;
      top: 6px;
      font-size: 14px;
      color: #fff;
      background-color: rgba(0,0,0,0.3);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      text-align: center;
      line-height: 18px;
      cursor: pointer;
    }

    /* Table / localStorage UI */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
    }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid #ddd;
    }
    th {
      background-color: #f2f2f2;
    }
    .deleteButton {
      background-color: red;
      color: white;
      padding: 5px 10px;
      margin-left: 10px;
      border: none;
      border-radius: 3px;
    }
    .deleteButton:hover {
      background-color: #cc0000;
    }

    .spinner {
      display: none; 
      width: 50px; 
      height: 50px;
      border: 5px solid #f3f3f3;
      border-radius: 50%;
      border-top: 5px solid #3498db;
      animation: spin 1s linear infinite;
      margin: 10px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .vis-tooltip {
      z-index: 10000 !important;
    }

    /* PATH-FINDING UI (WITH DROPDOWNS & SEARCH MODALS) */
    #pathContainer {
      display: flex; 
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 15px;
      gap: 10px;
    }
    #pathFrom, #pathTo {
      min-width: 150px;
      max-width: 200px;
    }
    /* The Search Modal */
    .search-modal-overlay {
      display: none; 
      position: fixed; 
      top:0; 
      left:0; 
      width:100%; 
      height:100%;
      background-color: rgba(0,0,0,0.7);
      z-index:3000;
    }
    .search-modal {
      background-color: #fff;
      width: 90%;
      max-width: 500px;
      margin: 50px auto;
      position: relative;
      padding: 20px;
      border-radius: 6px;
    }
    .close-search-modal {
      position: absolute;
      top: 10px; 
      right: 10px; 
      border: none; 
      background: none; 
      font-size: 18px; 
      cursor: pointer;
    }
    #searchInputFrom, #searchInputTo {
      width: 100%;
      padding: 6px;
      margin-bottom: 10px;
      font-size: 14px;
    }
    .searchResultList {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin: 0; 
      padding: 0;
      list-style: none;
    }
    .searchResultList li {
      padding: 6px 8px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
    }
    .searchResultList li:hover {
      background-color: #eee;
    }

    /* PATH RESULT BOX */
    #pathResult {
      display: none;
      border: 1px solid #ccc;
      background-color: #fafafa;
      padding: 8px 10px;
      border-radius: 4px;
      margin-top: 10px;
      position: relative;
      max-width: 600px;
    }
    #pathResult h4 {
      margin: 0 0 5px 0;
      font-size: 14px;
    }
    #pathList {
      margin: 0; 
      padding-left: 20px;
    }
    #pathList li {
      margin: 3px 0;
      font-size: 13px;
    }
    .closePathBtn {
      position: absolute;
      top: 5px; 
      right: 8px;
      cursor: pointer;
      background: none;
      border: none;
      font-size: 14px;
      color: #666;
    }
    .closePathBtn:hover {
      color: #000;
    }

    /* Kanban Comment MODAL for item titles */
    #kanbanCommentModalOverlay {
      display: none;
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 4000;
    }
    #kanbanCommentModal {
      background-color: #fff;
      width: 90%;
      max-width: 500px;
      margin: 50px auto;
      position: relative;
      padding: 20px;
      border-radius: 6px;
    }
    #kanbanCommentModalClose {
      position: absolute;
      top: 10px; 
      right: 10px; 
      border: none; 
      background: none; 
      font-size: 18px; 
      cursor: pointer;
    }
    #kanbanCommentModalContent {
      font-size: 14px;
      white-space: pre-line;
    }

    /* Footer styles */
    .site-footer {
      background-color: #333;
      color: #fff;
      text-align: center;
      padding: 20px 10px;
      margin-top: 40px;
      font-size: 14px;
    }
    .site-footer a {
      color: #4CAF50;
      text-decoration: none;
    }
    .site-footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
<div class="content-container">

  <p>Let's make the complex simple and fun!</p>
  <p>Try this instead of multi-slides Powerpoint presentations or long, serial texts.</p>
  <p>Boil it down to nodes and relationships between them.</p>
  <p>You can click on a node and only see its descendants.</p>
  <p>You can drag the nodes.</p>
  <h2>You will STAND OUT from your peers.</h2>
  <br>
  
  <p>Examples of use cases:</p>
  <ul>
    <li>Drug interactions</li>
    <li>Human anatomy</li>
    <li>Disease pathways</li>
    <li>Genograms</li>
    <li>Clinical history</li>  
    <li>Gene networks</li>  
    <li>Microbiome interactions</li>
    <li>Integration of clinical studies</li>
    <li>Healthcare provider networks</li>
  </ul>
  <p>Simply use the Sheets template file, insert your nodes and links between them, share the Sheets on the Web as .xlsx, copy the url, paste it here and load it.</p>  
  <p>Then you can work side by side, making changes on the Sheets Document and loading the data again here.</p>
  
  <br>
  <div class="separator" style="clear: both;">
    <a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3veNG49iQouf0DITSzDZmn0urtwGt5t3hJBR30Qg4Pz1DwQ8MciogfeXKHzzTeTaao9BpFE_vsq3jLrwD1Cs8sA53cn7vULuByqbj0gE46dR5DB0sDet3ZROcwOrQ7ND3HvspWsXktoC34G_Byv5gi9L4gQdg3ZsQpzS-FjUQOFLGr9msi2fdfr4ruv7V/s2127/network_example.png">
      <img border="0" data-original-height="1103" data-original-width="2127" height="333" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3veNG49iQouf0DITSzDZmn0urtwGt5t3hJBR30Qg4Pz1DwQ8MciogfeXKHzzTeTaao9BpFE_vsq3jLrwD1Cs8sA53cn7vULuByqbj0gE46dR5DB0sDet3ZROcwOrQ7ND3HvspWsXktoC34G_Byv5gi9L4gQdg3ZsQpzS-FjUQOFLGr9msi2fdfr4ruv7V/w640-h333/network_example.png" width="640" />
    </a>
  </div>

  <div class="spinner" id="loadingSpinner"></div>  
  
  <br>
  <button onclick="refreshPage()" class="button">Refresh</button>
  <button id="toggleFullscreen" class="button">Fullscreen</button>
  <br><br>

  <input type="checkbox" id="physicsCheck" checked> Physics
  <br><br>

  <label>
    <input type="checkbox" id="seeAllDescendantsCheckbox" name="seeAllDescendants">
    See all descendants
  </label>
  <br><br>

  <label>
    <input type="checkbox" id="curvedEdgesCheckbox"> Curved Edges
  </label>
  <br><br>

  <label>
    <input type="checkbox" id="edgesColorCheckbox" checked> Edges Colors
  </label>
  <br><br>

  <div style="margin-bottom: 10px;">
    <div id="groupToggles" style="display: inline-block;"></div>
    <div id="colorGradingToggles" style="display: inline-block; margin-left: 30px;"></div>
  </div>

  <!-- PATH-FINDING UI -->
  <div id="pathContainer">
    <label>From:</label>
    <select id="pathFrom"></select>
    <button class="button" onclick="openSearchModal('from')">Search</button>

    <label>To:</label>
    <select id="pathTo"></select>
    <button class="button" onclick="openSearchModal('to')">Search</button>

    <button onclick="findPath()" class="button">Find Path</button>
  </div>

  <!-- The search modal for FROM -->
  <div id="searchModalFrom" class="search-modal-overlay" onclick="maybeCloseSearchModal(event, 'from')">
    <div class="search-modal">
      <button class="close-search-modal" onclick="closeSearchModal('from')">X</button>
      <input type="text" id="searchInputFrom" placeholder="Type to filter..." oninput="filterSearch('from')">
      <ul id="searchResultsFrom" class="searchResultList"></ul>
    </div>
  </div>
  <!-- The search modal for TO -->
  <div id="searchModalTo" class="search-modal-overlay" onclick="maybeCloseSearchModal(event, 'to')">
    <div class="search-modal">
      <button class="close-search-modal" onclick="closeSearchModal('to')">X</button>
      <input type="text" id="searchInputTo" placeholder="Type to filter..." oninput="filterSearch('to')">
      <ul id="searchResultsTo" class="searchResultList"></ul>
    </div>
  </div>

  <!-- PATH RESULT BOX -->
  <div id="pathResult">
    <button class="closePathBtn" onclick="closePathResult()">X</button>
    <h4>Path</h4>
    <ol id="pathList" style="margin:0;"></ol>
  </div>

  <!-- ERROR PANEL: appears immediately before the network rectangle -->
  <div id="errorPanel" aria-live="polite"></div>

  <div id="mynetwork"></div>

  <div id="kanbanContainer" style="display: none;">
    <h3>Kanban Board</h3>
    <div class="kanban-board" id="kanbanBoard"></div>
  </div>

  <!-- Kanban Comment Modal -->
  <div id="kanbanCommentModalOverlay" onclick="maybeCloseKanbanCommentModal(event)">
    <div id="kanbanCommentModal">
      <button id="kanbanCommentModalClose" onclick="closeKanbanCommentModal()">X</button>
      <div id="kanbanCommentModalContent"></div>
    </div>
  </div>

  <a href="https://docs.google.com/spreadsheets/d/1BlMLCKcZed6vBTde19MLxtS-LElQVvYWQOms9_T-MPo/copy" target="_blank">Sheets Template</a>
  <br>

  <input type="text" id="dataURL" 
    value="https://docs.google.com/spreadsheets/d/e/2PACX-1vToVliu-S3QSp7qP0WgtdhPFioBNTXG-LbLFxMaYZSL8bec-96v0LzK8Z2txq0-IhPl9y30Bt8lHDL9/pub?output=xlsx" 
    style="width: 60%;">
  <button id="loadDataButton" class="button">Load</button>
  <button id="shareButton" class="button">Share</button>
  
  <p>You can also save multiple networks below so that the next time you load the website on this device, you'll have them here.</p>
  <button onclick="addRow()" class="button">Add New Row</button>
  <button id="resetButton" onclick="resetData()" class="button" style="background-color: #f44336;">Reset</button>
  <button onclick="downloadUrlTable()" class="button">Download Table</button>
  <button onclick="document.getElementById('uploadTableFile').click();" class="button">Upload Table</button>
  <input type="file" id="uploadTableFile" accept=".json" style="display:none" onchange="uploadUrlTableFile(event)">

  <table id="urlTable">
    <tr>
      <th>Title</th>
      <th>URL</th>
      <th>Action</th>
    </tr>
  </table>
  
  <br><br>
  
  <a href="https://github.com/andrefrsilva/sheets2network/raw/main/sheets2network_template.xlsx" target="_blank">Excel Template</a> 
  <br>
  <input accept=".xlsx, .xls" capture="" id="inputExcel" type="file" />
  
  <br>
  <h3>Analytics</h3>
  <button id="calculateNodeDegrees" class="button">Nodes' Degrees</button>
  <button onclick="degree()">Info</button>
  <canvas id="degreeChart"></canvas>
  <div id="nodeDegreeResults" style="display:none;"></div>

  <br><br>
  <button id="calculateClusteringCoefficient" style="display:none;" class="button">Clustering Coefficient</button>
  <button onclick="clusteringCoefficient()" style="display:none;">Info</button>
  <canvas id="clusteringChart"></canvas>
  <div id="clusteringResults" style="display:none;"></div>
</div> <!-- end content-container -->

<!-- Footer -->
<footer class="site-footer">
  <p>&copy; 2026 André FR Silva. All rights reserved.</p>
  <p>
    <a href="https://github.com/andrefrsilva/sheets2network" target="_blank">GitHub Repository</a>
  </p>
</footer>

<script>
  /***************
   * GitHub Pages Base URL
   ***************/
  var SITE_BASE_URL = 'https://andrefrsilva.github.io/sheets2network/';

  /***************
   * URL Table / localStorage
   ***************/
  function addShareButton(row) {
      var shareCell = row.insertCell(-1);
      var shareButton = document.createElement("button");
      shareButton.textContent = "Share";
      shareButton.className = "button";
      shareButton.addEventListener("click", function() {
          var urlInput = row.querySelector(".urlInput").value;
          var fullUrl = SITE_BASE_URL + '?sheetsUrl=' + encodeURIComponent(urlInput);
          navigator.clipboard.writeText(fullUrl).then(() => {
              alert("The URL was copied.");
          }, (err) => {
              console.error('Could not copy text: ', err);
          });
      });
      shareCell.appendChild(shareButton);
  }

  function addRow(title = '', url = '') {
      var table = document.getElementById("urlTable");
      var row = table.insertRow(-1);
      var titleCell = row.insertCell(0);
      var urlCell = row.insertCell(1);
      var actionCell = row.insertCell(2);

      titleCell.innerHTML = `<input type="text" value="${title}" class="titleInput" style="width: 100%;">`;
      urlCell.innerHTML = `<input type="text" value="${url}" class="urlInput" style="width: 100%;">`;
      actionCell.innerHTML = `<button class="loadButton button" onclick="loadURL(this)">Load</button>`;

      var shareButton = document.createElement("button");
      shareButton.className = "button";
      shareButton.textContent = "Share";
      shareButton.style.marginLeft = "10px";
      shareButton.onclick = function() {
          var urlInput = row.querySelector(".urlInput").value;
          var fullUrl = SITE_BASE_URL + '?sheetsUrl=' + encodeURIComponent(urlInput);
          navigator.clipboard.writeText(fullUrl).then(() => {
              alert("The URL was copied.");
          }, (err) => {
              console.error('Could not copy text: ', err);
          });
      };
      actionCell.appendChild(shareButton);

      var deleteButton = document.createElement("button");
      deleteButton.className = "deleteButton button";
      deleteButton.textContent = "x";
      deleteButton.style.marginLeft = "10px"; 
      deleteButton.onclick = function() {
          deleteRow(this.parentNode.parentNode);
      };
      actionCell.appendChild(deleteButton);

      titleCell.querySelector('input').addEventListener('change', saveToStorage);
      urlCell.querySelector('input').addEventListener('change', saveToStorage);
  }

  function loadURL(btn) {
      var url = btn.closest('tr').querySelector('.urlInput').value;
      document.getElementById('dataURL').value = url;
      document.getElementById('loadDataButton').click();
  }

  function deleteRow(btn) {
      var row = btn.closest('tr');
      row.parentNode.removeChild(row);
      saveToStorage();
  }

  function saveToStorage() {
      var data = [];
      var rows = document.getElementById("urlTable").rows;
      for (var i = 1; i < rows.length; i++) {
          var title = rows[i].cells[0].querySelector('input').value;
          var url = rows[i].cells[1].querySelector('input').value;
          data.push({title, url});
      }
      localStorage.setItem("urlData", JSON.stringify(data));
  }

  function loadFromStorage() {
      var stored = localStorage.getItem("urlData");
      if(!stored) return;
      var data = JSON.parse(stored);
      data.forEach(function(item) {
          addRow(item.title, item.url);
      });
  }

  function resetData() {
      localStorage.clear();
      var table = document.getElementById("urlTable");
      while(table.rows.length > 1) {
        table.deleteRow(1);
      }
  }

  function refreshPage() {
      location.reload();
  }

  // Download & Upload Table
  function downloadUrlTable() {
    let stored = localStorage.getItem("urlData");
    if(!stored) stored="[]";
    let blob = new Blob([stored], {type:"application/json"});
    let url = URL.createObjectURL(blob);
    let a = document.createElement("a");
    a.href=url;
    a.download="sheets2network_table.json";
    a.click();
    URL.revokeObjectURL(url);
  }
  function uploadUrlTableFile(evt) {
    let file=evt.target.files[0];
    if(!file)return;
    let reader=new FileReader();
    reader.onload=function(e){
      try {
        let arr=JSON.parse(e.target.result);
        resetData();
        arr.forEach(item=>addRow(item.title,item.url));
        saveToStorage();
      } catch(e){
        alert("Invalid JSON file.");
      }
    };
    reader.readAsText(file);
  }

  /***************
   * Analytics Helper Functions
   ***************/
  function degree() {
      alert("The degree is simply the number of edges connected to a node.");
  }
  function clusteringCoefficient() {
      alert("The clustering coefficient is a measure of the degree to which nodes in a graph tend to cluster together.");
  }
  function betweennessCentrality() {
      alert("Betweenness centrality is the number of paths between two nodes that go through the node.");
  }
  function closenessCentrality() {
      alert("Closeness centrality is a way of detecting nodes that spread information efficiently through a graph.");
  }

  function calculateNodeDegrees() {
      let degrees = {};
      nodes.forEach(node => {
          let degree = edges.get({
              filter: function(edge) {
                  return edge.from === node.id || edge.to === node.id;
              }
          }).length;
          degrees[node.id] = degree;
      });
      return degrees;
  }

  function calculateClusteringCoefficient() {
      let coefficients = {};
      nodes.forEach(node => {
          let neighbors = edges.get({
              filter: function(edge) {
                  return edge.from === node.id || edge.to === node.id;
              }
          }).map(edge => edge.from === node.id ? edge.to : edge.from);
          let neighborCount = neighbors.length;
          if (neighborCount > 1) {
              let linkCount = 0;
              for (let i = 0; i < neighborCount; i++) {
                  for (let j = i + 1; j < neighborCount; j++) {
                      if (edges.get({
                          filter: function(edge) {
                              return (edge.from === neighbors[i] && edge.to === neighbors[j]) || 
                                     (edge.from === neighbors[j] && edge.to === neighbors[i]);
                          }
                      }).length > 0) {
                          linkCount++;
                      }
                  }
              }
              let clustering = 2.0 * linkCount / (neighborCount * (neighborCount - 1));
              coefficients[node.id] = clustering;
          }
      });
      return coefficients;
  }

  function updateResults(coefficients) {
      let results = document.getElementById('clusteringResults');
      let chartCanvas = document.getElementById('clusteringChart');
      if (results.style.display === 'block') {
          results.style.display = 'none';
          chartCanvas.style.display = 'none';
          return;
      }
      results.innerHTML = '';
      let sortedNodes = Object.keys(coefficients).sort((a, b) => coefficients[b] - coefficients[a]);
      let table = document.createElement('table');
      let headers = ['Coefficient', 'Node'];
      let headerRow = document.createElement('tr');
      headers.forEach(headerText => {
          let header = document.createElement('th');
          header.textContent = headerText;
          headerRow.appendChild(header);
      });
      table.appendChild(headerRow);

      sortedNodes.forEach(nodeId => {
          let row = document.createElement('tr');
          let coeffCell = document.createElement('td');
          coeffCell.textContent = coefficients[nodeId].toFixed(3);
          row.appendChild(coeffCell);

          let nodeIdCell = document.createElement('td');
          nodeIdCell.textContent = nodeId;
          row.appendChild(nodeIdCell);

          table.appendChild(row);
      });

      results.appendChild(table);
      results.style.display = 'block';
      chartCanvas.style.display = 'block';
      drawClusteringChart(coefficients);
  }

  document.getElementById("calculateClusteringCoefficient").addEventListener("click", function() {
      let coefficients = calculateClusteringCoefficient();
      updateResults(coefficients);
  });

  function drawClusteringChart(coefficients) {
      let data = Object.values(coefficients);
      if(!data.length) return;
      let borderColor = 'rgba(255, 99, 132, 1)';
      let borderWidth = 1;
      let min = Math.min(...data);
      let max = Math.max(...data);
      let interval = (max - min) / 10;
      let histogramData = {
        labels: [],
        datasets: [{
          label: 'Clustering Coefficients',
          data: [],
          backgroundColor: 'rgba(255, 99, 132, 0.2)',
          borderColor: borderColor,
          borderWidth: borderWidth
        }]
      };
      for (let i = min; i <= max; i += interval) {
          let lowerBound = i.toFixed(2);
          let upperBound = (i + interval).toFixed(2);
          let label = `${lowerBound} - ${upperBound}`;
          let count = data.filter(value => value >= i && value < (i + interval)).length;
          histogramData.labels.push(label);
          histogramData.datasets[0].data.push(count);
      }
      let histogramOptions = {
        indexAxis: 'x',
        elements: {
          bar: { borderWidth: 2 }
        },
        scales: {
          y: {
            beginAtZero: true,
            title: { display: true, text: 'Count' }
          },
          x: {
            title: { display: true, text: 'Range' }
          }
        }
      };
      new Chart(document.getElementById('clusteringChart'), {
        type: 'bar',
        data: histogramData,
        options: histogramOptions
      });
  }

  let degreeChart;
  document.getElementById("calculateNodeDegrees").addEventListener("click", function() {
      let degrees = calculateNodeDegrees();
      let degreeCanvas = document.getElementById('degreeChart');
      if (updateDegreeResults(degrees)) {
          drawDegreeHistogram(degrees);
      } else {
          degreeCanvas.style.display = 'none';
      }
  });

  function updateDegreeResults(degrees) {
      let results = document.getElementById('nodeDegreeResults');
      let chartCanvas = document.getElementById('degreeChart');
      if (results.style.display === 'block') {
          results.style.display = 'none';
          chartCanvas.style.display = 'none';
          if (degreeChart) {
              degreeChart.destroy();
              degreeChart = null;
          }
          return false;
      }
      results.innerHTML = '';
      let sortedNodes = Object.keys(degrees).sort((a, b) => degrees[b] - degrees[a]);
      let table = document.createElement('table');
      let headers = ['Degree', 'Node'];
      let headerRow = document.createElement('tr');
      headers.forEach(headerText => {
          let header = document.createElement('th');
          header.textContent = headerText;
          headerRow.appendChild(header);
      });
      table.appendChild(headerRow);

      sortedNodes.forEach(nodeId => {
          let row = document.createElement('tr');
          let degreeCell = document.createElement('td');
          degreeCell.textContent = degrees[nodeId];
          row.appendChild(degreeCell);

          let nodeIdCell = document.createElement('td');
          nodeIdCell.textContent = nodeId;
          row.appendChild(nodeIdCell);

          table.appendChild(row);
      });

      results.appendChild(table);
      results.style.display = 'block';
      chartCanvas.style.display = 'block';
      return true;
  }

  function drawDegreeHistogram(degrees) {
      let totalDegrees = Object.values(degrees).length;
      let degreePercentages = {};
      Object.values(degrees).forEach(d => {
          degreePercentages[d] = (degreePercentages[d] || 0) + (1 / totalDegrees * 100);
      });
      let labels = Object.keys(degreePercentages);
      let data = Object.values(degreePercentages);
      if (degreeChart) {
          degreeChart.destroy();
          degreeChart = null;
      }
      let ctx = document.getElementById('degreeChart');
      ctx.style.display = 'block';
      degreeChart = new Chart(ctx, {
          type: 'bar',
          data: {
              labels: labels,
              datasets: [{
                  label: 'Degree Distribution (%)',
                  data: data,
                  backgroundColor: 'rgba(75, 192, 192, 0.2)',
                  borderColor: 'rgba(75, 192, 192, 1)',
                  borderWidth: 1
              }]
          },
          options: {
              scales: {
                  x: {
                      title: { display: true, text: 'Degree' }
                  },
                  y: {
                      title: { display: true, text: 'Percentage' },
                      ticks: {
                          callback: function(value) { return value + '%'; }
                      }
                  }
              }
          }
      });
  }

  /***************
   * Create the Network
   ***************/
  var container = document.getElementById("mynetwork");
  var nodes = new vis.DataSet([]);
  var edges = new vis.DataSet([]);
  var adjacencyList={};
  var options = {
    layout: { randomSeed: 2 },
    physics: {
      enabled: true,
      solver: "barnesHut",
      barnesHut: {
        gravitationalConstant: -8000,
        springLength: 50,
        centralGravity: 0.01,
      },
      maxVelocity: 135,
      timestep: 0.35,
      stabilization: {
        enabled: true,
        iterations: 600,
        updateInterval: 10,
        onlyDynamicEdges: false,
        fit: true
      }
    },
    nodes: {
      shape: "dot",
      scaling: {
        customScalingFunction: function (min, max, total, value) {
          return value / total;
        },
        min: 5,
        max: 50,
      },
    },
    edges: {
      color: { inherit: false },
      width: 1,    
      length: 100, 
      smooth: { enabled: false, type: 'dynamic' },
    },
  };
  var network = new vis.Network(container, {nodes:nodes, edges:edges}, options);

  // Edges color toggling
  document.getElementById("edgesColorCheckbox").addEventListener("change", function() {
    if(this.checked) {
      edges.forEach(function(e) {
        edges.update({ id: e.id, color: e.originalColor || 'gray' });
      });
    } else {
      edges.forEach(function(e) {
        edges.update({ id: e.id, color: 'gray' });
      });
    }
  });
  // Physics toggle
  document.getElementById("physicsCheck").addEventListener("change", function() {
    options.physics.enabled = this.checked;
    network.setOptions(options);
    network.redraw();
  });
  // Curved edges toggle
  document.getElementById("curvedEdgesCheckbox").addEventListener("change", function () {
    options.edges.smooth.enabled = this.checked;
    network.setOptions(options);
    network.redraw();
  });

  // Node selection => show/hide descendants
  network.on('selectNode', function (properties) {
    let seeAllDescendants = document.getElementById('seeAllDescendantsCheckbox').checked;
    let nodesToUpdate = [];
    let allNodes = nodes.get();
    // Hide all except selected
    allNodes.forEach(node => {
      if (properties.nodes.includes(node.id)) {
        nodesToUpdate.push({ id: node.id, hidden: false, color: node.color });
      } else {
        nodesToUpdate.push({ id: node.id, hidden: true });
      }
    });
    // Recursively add child nodes if seeAllDescendants
    const addChildNodes = (nodeId, nodesMap, recursive = true) => {
      let connectedEdges = edges.get({ filter: function(edge){ return edge.from === nodeId; } });
      connectedEdges.forEach((edge) => {
        let childId = edge.to;
        let childNode = nodesMap.find(n => n.id === childId);
        if(childNode && childNode.hidden) {
          childNode.hidden = false;
          childNode.color = nodes.get(childId).color; 
          if(recursive) {
            addChildNodes(childId, nodesMap);
          }
        }
      });
    };
    properties.nodes.forEach(nodeId => {
      addChildNodes(nodeId, nodesToUpdate, seeAllDescendants);
    });
    nodes.update(nodesToUpdate);
  });
  network.on('deselectNode', function (properties) {
    let nodesToUpdate = [];
    let allNodes = nodes.get();
    allNodes.forEach(node => {
      if(node.hidden){ 
        nodesToUpdate.push({ id: node.id, hidden: false, color: node.color });
      }
    });
    nodes.update(nodesToUpdate);
  });

  // Fullscreen
  function enterFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    }
  }
  function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
  function isFullscreen() {
    return !!(document.fullscreenElement || document.webkitFullscreenElement || 
              document.mozFullScreenElement || document.msFullscreenElement);
  }
  document.getElementById("toggleFullscreen").addEventListener("click", function() {
    if(isFullscreen()) {
      exitFullscreen();
    } else {
      enterFullscreen(container);
    }
  });

  // Group Toggles
  var groupFilters = {};
  function renderGroupToggles() {
    var toggleContainer = document.getElementById("groupToggles");
    toggleContainer.innerHTML = "";
    Object.keys(groupFilters).forEach(function(group) {
      var btn = document.createElement("button");
      btn.innerText = group;
      btn.classList.add("toggleBtn");
      if(!groupFilters[group]) btn.classList.add("off");
      btn.onclick = function() {
        groupFilters[group] = !groupFilters[group];
        btn.classList.toggle("off", !groupFilters[group]);
        updateNetworkVisibility();
      };
      toggleContainer.appendChild(btn);
    });
  }
  function updateNetworkVisibility() {
    nodes.forEach(function(node) {
      let hide = node.group && !groupFilters[node.group];
      nodes.update({ id: node.id, hidden: hide, color: node.color });
    });
    edges.forEach(function(edge) {
      let fromNode = nodes.get(edge.from);
      let toNode = nodes.get(edge.to);
      edges.update({ id: edge.id, hidden: (fromNode.hidden || toNode.hidden) });
    });
  }

  // Color Grading
  var sortColumns = [];
  var currentColorGrading = null;
  function renderColorGradingToggles() {
    var container = document.getElementById("colorGradingToggles");
    container.innerHTML = "";
    if(sortColumns.length === 0) return;

    var label = document.createElement("span");
    label.style.fontWeight = "bold";
    label.innerText = "Color Grading: ";
    container.appendChild(label);

    sortColumns.forEach(function(colName) {
      var displayName = colName.replace(/^sort_/, "");
      var btn = document.createElement("button");
      btn.classList.add("toggleBtn");
      if(currentColorGrading !== colName) btn.classList.add("off");
      btn.innerText = displayName;
      btn.onclick = function() {
        toggleColorGrading(colName);
        var siblings = container.querySelectorAll(".toggleBtn");
        siblings.forEach(s => s.classList.add("off"));
        if(currentColorGrading === colName) {
          btn.classList.remove("off");
        } else {
          btn.classList.add("off");
        }
        buildKanban();
      };
      container.appendChild(btn);
    });
  }
  function toggleColorGrading(colName) {
    if(currentColorGrading === colName) {
      resetNodeColors();
      currentColorGrading = null;
    } else {
      applyColorGrading(colName);
      currentColorGrading = colName;
    }
  }
  function resetNodeColors() {
    nodes.forEach(n => {
      nodes.update({ id:n.id, color:n.originalColor });
    });
  }
  var negativeGradient = generateGradient("#0000FF","#000000",10);
  var positiveGradient = generateGradient("#000000","#FF0000",10);

  function applyColorGrading(colName) {
    let minVal=Infinity, maxVal=-Infinity;
    let numericValues=[];
    nodes.forEach(n=>{
      let val=(n.sortData && typeof n.sortData[colName]==='number')? n.sortData[colName]: null;
      if(val!==null && !isNaN(val)) numericValues.push(val);
    });
    if(numericValues.length>0) {
      minVal=Math.min(...numericValues);
      maxVal=Math.max(...numericValues);
    } else return;

    nodes.forEach(n=>{
      let val=(n.sortData && typeof n.sortData[colName]==='number')? n.sortData[colName]: null;
      let c=getGradedColor(val,minVal,maxVal);
      nodes.update({ id:n.id, color:c });
    });
  }
  function getGradedColor(value,minVal,maxVal){
    if(value===null||isNaN(value)) return "#808080";
    if(minVal>=0){
      let steps=positiveGradient.length;
      if(minVal===maxVal) return positiveGradient[steps-1];
      let frac=(value-minVal)/(maxVal-minVal);
      let idx=Math.round(frac*(steps-1));
      return positiveGradient[idx];
    }
    if(maxVal<=0){
      let steps=negativeGradient.length;
      if(minVal===maxVal) return negativeGradient[0];
      let frac=(value-minVal)/(maxVal-minVal);
      let idx=Math.round(frac*(steps-1));
      if(idx<0) idx=0;
      if(idx>steps-1) idx=steps-1;
      return negativeGradient[idx];
    }
    if(value<0){
      let steps=negativeGradient.length;
      let negRange=Math.abs(minVal);
      let frac=(value-minVal)/negRange;
      let idx=Math.round(frac*(steps-1));
      if(idx<0) idx=0;
      if(idx>steps-1) idx=steps-1;
      return negativeGradient[idx];
    } else if(value>0){
      let steps=positiveGradient.length;
      let posRange=maxVal;
      let frac=value/posRange;
      let idx=Math.round(frac*(steps-1));
      if(idx<0) idx=0;
      if(idx>steps-1) idx=steps-1;
      return positiveGradient[idx];
    } else {
      return "#000000";
    }
  }
  function generateGradient(startColor,endColor,steps){
    let start=hexToRgb(startColor), end=hexToRgb(endColor);
    let arr=[];
    for(let i=0;i<steps;i++){
      let t=i/(steps-1);
      let r=Math.round(start.r+t*(end.r-start.r));
      let g=Math.round(start.g+t*(end.g-start.g));
      let b=Math.round(start.b+t*(end.b-start.b));
      arr.push(rgbToHex(r,g,b));
    }
    return arr;
  }
  function hexToRgb(hex){
    hex=hex.replace(/^#/,'');
    if(hex.length===3){
      hex=hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    }
    let num=parseInt(hex,16);
    return{ r:(num>>16)&255,g:(num>>8)&255,b:num&255};
  }
  function rgbToHex(r,g,b){
    return"#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();
  }

  /***************
   * Kanban Board + (i) icon => open modal
   ***************/
  var kanbanValues=[];
  var columnColors={}; 
  function buildKanban(){
    var kanbanContainer=document.getElementById("kanbanContainer");
    var kanbanBoard=document.getElementById("kanbanBoard");
    kanbanBoard.innerHTML="";
    if(kanbanValues.length===0){
      kanbanContainer.style.display="none";
      return;
    }
    kanbanContainer.style.display="block";

    kanbanValues.forEach(kv=>{
      if(!columnColors[kv]){
        columnColors[kv]=generatePastelColor();
      }
      var colDiv=document.createElement("div");
      colDiv.className="kanban-column";
      colDiv.style.backgroundColor=columnColors[kv];

      var titleEl=document.createElement("div");
      titleEl.className="kanban-column-title";
      titleEl.innerText=kv;
      colDiv.appendChild(titleEl);

      var primarySortCol=(sortColumns.length>0)?sortColumns[0]:null;
      var nodeIds=nodes.getIds().filter(id=>nodes.get(id).kanbanValue===kv);
      // sort descending if numeric
      nodeIds.sort((a,b)=>{
        let nA=nodes.get(a),nB=nodes.get(b);
        let vA=(primarySortCol && nA.sortData)?nA.sortData[primarySortCol]:null;
        let vB=(primarySortCol && nB.sortData)?nB.sortData[primarySortCol]:null;
        if(!vA)vA=0;if(!vB)vB=0;
        // descending
        if(vB!==vA)return vB-vA;
        return(nA.label||"").localeCompare(nB.label||"");
      });

      nodeIds.forEach(nid=>{
        let n=nodes.get(nid);
        var cardDiv=document.createElement("div");
        cardDiv.className="kanban-card";
        cardDiv.style.backgroundColor=n.color;
        cardDiv.innerText=n.label||nid;

        // If there's a comment, show the (i) icon in top-right corner
        if(n.title){
          let icon=document.createElement("div");
          icon.className="kanban-info-icon";
          icon.textContent="i";
          icon.addEventListener("click",function(ev){
            ev.stopPropagation(); // don't let the card's click happen
            openKanbanCommentModal(n.title);
          });
          cardDiv.appendChild(icon);
        }
        colDiv.appendChild(cardDiv);
      });
      kanbanBoard.appendChild(colDiv);
    });
  }

  // Generate a random pastel color for each column
  function generatePastelColor(){
    let r=200+Math.round(Math.random()*55);
    let g=200+Math.round(Math.random()*55);
    let b=200+Math.round(Math.random()*55);
    return`rgb(${r},${g},${b})`;
  }

  // Kanban comment modal logic
  function openKanbanCommentModal(txt){
    document.getElementById("kanbanCommentModalContent").innerText=txt;
    document.getElementById("kanbanCommentModalOverlay").style.display='block';
  }
  function closeKanbanCommentModal(){
    document.getElementById("kanbanCommentModalOverlay").style.display='none';
  }
  function maybeCloseKanbanCommentModal(e){
    if(e.target.id==='kanbanCommentModalOverlay'){
      closeKanbanCommentModal();
    }
  }

  /***************
   * BFS Path-Finding (Directional) + Edge Thickness
   ***************/
  function findPath() {
    // restore edges to original thickness
    edges.forEach(e=>{
      edges.update({ id:e.id, width:(typeof e.width==='number'?e.width:1) });
    });
    // hide path result
    document.getElementById('pathResult').style.display='none';
    document.getElementById('pathList').innerHTML='';

    let fromId = document.getElementById('pathFrom').value;
    let toId   = document.getElementById('pathTo').value;
    if(!fromId||!toId){
      alert("Please select 'From' and 'To' nodes.");
      return;
    }
    if(fromId===toId){
      alert("They're the same node!");
      return;
    }
    let path = bfsDirectionalPath(fromId,toId);
    if(!path){
      document.getElementById('pathResult').style.display='block';
      document.getElementById('pathList').innerHTML='<li>No path found.</li>';
      return;
    }
    // set all edges thickness=1
    edges.forEach(e=>{
      edges.update({ id:e.id, width:1 });
    });
    // highlight path edges => thickness=3
    for(let i=0;i<path.length-1;i++){
      let a=path[i], b=path[i+1];
      let match=edges.getIds({
        filter:(ed)=>(ed.from===a && ed.to===b)||(ed.from===b && ed.to===a)
      });
      if(match.length>0){
        edges.update({ id: match[0], width: 13 });
      }
    }
    // zoom
    network.fit({ nodes: path, animation:{ duration:600, easingFunction:"easeInOutQuad" }});
    // show path
    document.getElementById('pathResult').style.display='block';
    let listEl=document.getElementById('pathList');
    path.forEach(nid=>{
      let n=nodes.get(nid);
      let li=document.createElement('li');
      li.textContent=(n && n.label)? n.label : nid;
      listEl.appendChild(li);
    });
  }

  function bfsDirectionalPath(startId, goalId) {
    let visited=new Set();
    let queue=[startId];
    let parent={};
    visited.add(startId);
    while(queue.length>0){
      let current=queue.shift();
      if(current===goalId){
        let route=[];
        let tmp=goalId;
        while(tmp!==undefined){
          route.unshift(tmp);
          tmp=parent[tmp];
        }
        return route;
      }
      let neighbors=adjacencyList[current]||[];
      for(let nb of neighbors){
        if(!visited.has(nb)){
          visited.add(nb);
          parent[nb]=current;
          queue.push(nb);
        }
      }
    }
    return null;
  }

  function closePathResult(){
    document.getElementById('pathResult').style.display='none';
    document.getElementById('pathList').innerHTML='';
  }

  // For the search modals
  function openSearchModal(mode){
    if(mode==='from'){
      document.getElementById('searchModalFrom').style.display='block';
      filterSearch('from');
    } else {
      document.getElementById('searchModalTo').style.display='block';
      filterSearch('to');
    }
  }
  function closeSearchModal(mode){
    if(mode==='from'){
      document.getElementById('searchModalFrom').style.display='none';
    } else {
      document.getElementById('searchModalTo').style.display='none';
    }
  }
  function maybeCloseSearchModal(e, mode){
    if(mode==='from' && e.target.id==='searchModalFrom'){
      closeSearchModal('from');
    }
    if(mode==='to' && e.target.id==='searchModalTo'){
      closeSearchModal('to');
    }
  }
  function filterSearch(mode){
    let inputEl=(mode==='from')?document.getElementById('searchInputFrom'):document.getElementById('searchInputTo');
    let listEl =(mode==='from')?document.getElementById('searchResultsFrom'):document.getElementById('searchResultsTo');
    let val=inputEl.value.toLowerCase();
    let selectEl=(mode==='from')?document.getElementById('pathFrom'):document.getElementById('pathTo');
    let opts=Array.from(selectEl.options);

    listEl.innerHTML='';
    opts.forEach(opt=>{
      if(opt.text.toLowerCase().includes(val)){
        let li=document.createElement('li');
        li.textContent=opt.text;
        li.onclick=function(){
          selectEl.value=opt.value;
          closeSearchModal(mode);
        };
        listEl.appendChild(li);
      }
    });
  }

  /***************
   * Error panel helpers
   ***************/
  function clearErrorPanel(){
    const panel = document.getElementById('errorPanel');
    panel.innerHTML = '';
    panel.style.display = 'none';
  }
  function addErrorLine(msg){
    const panel = document.getElementById('errorPanel');
    const div = document.createElement('div');
    div.className = 'error-line';
    div.textContent = msg; // safe text (no HTML)
    panel.appendChild(div);
    panel.style.display = 'block';
  }
  function addSummarizedListError(prefix, arr, maxShow = 10){
    if(!arr.length) return;
    let shown = arr.slice(0, maxShow).join(', ');
    let more = arr.length > maxShow ? ` … (+${arr.length - maxShow} more)` : '';
    addErrorLine(`${prefix}: ${shown}${more}`);
  }

  // === Safe ASCII symbols for messages (avoid unicode encoding issues) ===
  const MSG_ARROW = '->';
  const MSG_UNDIR = '<->';
  function pairStr(a,b){ return `${a} ${MSG_ARROW} ${b}`; }
  function undirKey(a,b){
    return (a < b) ? `${a}${MSG_UNDIR}${b}` : `${b}${MSG_UNDIR}${a}`;
  }

  /***************
   * Load data from URL or File
   ***************/
  async function loadDataFromURL() {
    // Always append a fresh timestamp to bust cache:
    let baseUrl = document.getElementById("dataURL").value.trim();
    let finalUrl = baseUrl + (baseUrl.includes('?') ? '&' : '?') + 't=' + Date.now();

    document.getElementById("loadingSpinner").style.display="block";
    try {
      // No custom headers => avoids CORS issues on Google side
      let resp = await fetch(finalUrl, { cache: 'no-store' });
      if(!resp.ok) throw new Error("HTTP error " + resp.status);
      let blob = await resp.blob();
      processExcel(blob);
      localStorage.setItem('dataURL', baseUrl);
    } catch(e){
      console.error(e);
      addErrorLine("Error loading Excel from URL: " + e.message);
      alert("Error loading Excel from URL: " + e.message);
    } finally {
      document.getElementById("loadingSpinner").style.display="none";
    }
  }

  async function loadDefaultExcel() {
    // A default just for demonstration
    const defaultURL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQPXlADz_pJjakvXkfgFshXwE1BBgt-OlHbcPZyZ6QgUhGSTmKTutmGf481beIRAZ60MFJ-y_gJHnig/pub?output=xlsx";
    document.getElementById("dataURL").value = defaultURL;
    await loadDataFromURL();
  }

  document.getElementById("loadDataButton").addEventListener('click', loadDataFromURL);
  document.getElementById("inputExcel").addEventListener("change",function(evt){
    let file=evt.target.files[0];
    if(file) processExcel(file);
    else loadDefaultExcel();
  });

  function processExcel(blob) {
    // Clear all old data so we start fresh
    nodes.clear();
    edges.clear();
    groupFilters={};
    sortColumns=[];
    currentColorGrading=null;
    kanbanValues=[];
    adjacencyList={};
    clearErrorPanel();

    var reader=new FileReader();
    reader.onload=function(e){
      try{
        var data=e.target.result;
        var workbook=XLSX.read(data,{type:"binary"});

        // Sheets presence checks
        if(!workbook.Sheets["nodes"]){
          addErrorLine("Missing sheet 'nodes'. Please include a sheet named exactly 'nodes'.");
          return;
        }
        if(!workbook.Sheets["edges"]){
          addErrorLine("Missing sheet 'edges'. Please include a sheet named exactly 'edges'.");
          return;
        }

        // "nodes" sheet
        var nodesSheet=workbook.Sheets["nodes"];
        var allRows=XLSX.utils.sheet_to_json(nodesSheet,{header:1});
        if(!allRows||allRows.length<2){
          addErrorLine("The 'nodes' sheet has no data rows.");
          return;
        }
        var headerRow=allRows[0].map(h=>(h||"").trim());
        var nodeRows=allRows.slice(1);

        var sortIndexes=[];
        headerRow.forEach((colName,i)=>{
          if(colName.toLowerCase().startsWith("sort_")){
            sortIndexes.push(i);
            sortColumns.push(colName);
          }
        });

        // For capturing kanban and icon_url columns
        var kanbanIndex=headerRow.indexOf("kanban");
        var iconUrlIndex=headerRow.indexOf("icon_url");

        // Collect for validations
        let idSet = new Set();
        let idCollisionOriginals = {}; // normalizedId -> [labels...]
        let blankIdsRows = [];
        let badIconUrls = [];

        nodeRows.forEach((row, idx)=>{
          if(row.every(c=>c===undefined||c===null||c===""))return;
          var labelRaw = row[0];
          var nodeId=(row[0]?(""+row[0]).replace(/\s+/g,""):null);

          if(!nodeId){
            blankIdsRows.push(idx+2); // +2 accounts for header (1) and 1-based
            return; // skip adding node with empty id
          }
          // Detect duplicates after whitespace normalization
          if(!idSet.has(nodeId)){
            idSet.add(nodeId);
            idCollisionOriginals[nodeId] = [(""+labelRaw)];
          } else {
            idCollisionOriginals[nodeId].push((""+labelRaw));
          }

          var color=(row[1]? row[1]:"black");
          var value=(row[2]? row[2]:"");
          var title=(row[3]? row[3]:"");
          var group=(row[4]? row[4]:null);
          if(group) groupFilters[group]=true;

          var kanbanVal=null;
          if(kanbanIndex>=0 && row[kanbanIndex]){
            kanbanVal=row[kanbanIndex];
          }

          // Create default node object
          var nodeObj={
            id: nodeId,
            label: row[0],
            value: value,
            color: color,
            originalColor: color,
            title: title,
            group: group,
            hidden: group? !groupFilters[group]:false,
            sortData: {},
            kanbanValue: kanbanVal
          };

          // Check for icon_url; if present and valid, change shape to image
          if(iconUrlIndex > -1) {
            let iconUrl = row[iconUrlIndex] ? row[iconUrlIndex].toString().trim() : "";
            if(iconUrl){
              if(/^https?:\/\//i.test(iconUrl)){
                nodeObj.shape = "image";
                nodeObj.image = iconUrl;
              } else {
                badIconUrls.push(`${row[0]} → icon_url "${iconUrl}"`);
              }
            }
          }

          // For sorting columns like sort_*
          sortIndexes.forEach(si=>{
            let raw = row[si];
            let scVal=parseFloat(raw);
            if(raw!==undefined && raw!==null && raw!=="" && isNaN(scVal)){
              addErrorLine(`nodes: non-numeric value in "${headerRow[si]}" for node "${row[0]}": "${raw}"`);
              nodeObj.sortData[ headerRow[si] ] = null;
            } else {
              nodeObj.sortData[ headerRow[si] ] = (isNaN(scVal)?null:scVal);
            }
          });
          nodes.add(nodeObj);
        });

        // Report duplicate IDs (after trimming spaces)
        Object.keys(idCollisionOriginals).forEach(norm=>{
          if(idCollisionOriginals[norm].length>1){
            addErrorLine(`Duplicate node id after removing spaces: "${norm}". Original labels in rows: ${idCollisionOriginals[norm].join(' | ')}`);
          }
        });
        if(blankIdsRows.length){
          addErrorLine(`nodes: empty/blank Node ID in row(s): ${blankIdsRows.join(', ')} (first column). These rows were ignored.`);
        }
        if(badIconUrls.length){
          addErrorLine(`nodes: invalid icon_url (must start with http/https). Examples: ${badIconUrls.slice(0,5).join(' ; ')}${badIconUrls.length>5?` … (+${badIconUrls.length-5} more)`:''}`);
        }

        // "edges" sheet
        var edgesSheet=workbook.Sheets["edges"];
        var edgesData=XLSX.utils.sheet_to_json(edgesSheet,{header:1});
        if(!edgesData || edgesData.length<2){
          addErrorLine("The 'edges' sheet has no data rows.");
        }
        edgesData.shift(); // drop header

        // Validations on edges
        let unknownFrom = [];
        let unknownTo = [];
        let missingFrom = [];
        let missingTo = [];
        let caseSuggests = []; // {row, typed, suggestion}
        let dupEdgeLines = [];
        let selfLoops = [];
        let unknownRelations = [];
        let nonNumericVals = [];
        let bidirectionalDuplicates = [];

        let existingIds = new Set(nodes.getIds());
        let idLowerMap = {};
        existingIds.forEach(id => { idLowerMap[id.toLowerCase()] = id; });

        let seenDir = new Set();
        let seenUndir = new Set();

        edgesData.forEach((row, idx)=>{
          if(row.every(cell=>cell===undefined||cell===null||cell===""))return;

          const rowNum = idx + 2; // header offset

          // relation / style
          var relation=(row[2]?(""+row[2]).trim().toLowerCase():"");
          var colorE="grey";
          var dashes=false;
          if(relation==="promotes") colorE="green";
          else if(relation==="inhibits") colorE="red";
          else if(relation==="link"){ colorE="black"; dashes=true; }
          else if(relation!==""){
            unknownRelations.push({row: rowNum, value: relation});
          }

          var title=(row[4]? row[4]:"");

          // value
          var rawVal=row[3];
          var val=(row[3]? parseFloat(row[3]):undefined);
          if(rawVal!==undefined && rawVal!==null && rawVal!=="" && isNaN(parseFloat(rawVal))){
            nonNumericVals.push({row: rowNum, value: rawVal});
          }
          var thickness=0.5, length=100;
          if(val!==undefined && !isNaN(val)){
            thickness=Math.max(0.5,0.5+(val/100)*(10-0.5));
            length=Math.max(1,5-(val/100)*(5-1));
          }

          // endpoints (normalize)
          var fromNode=(row[0]? (""+row[0]).replace(/\s+/g,""):"");
          var toNode  =(row[1]? (""+row[1]).replace(/\s+/g,""):"");

          // explicit missing
          if(!fromNode) missingFrom.push(rowNum);
          if(!toNode)   missingTo.push(rowNum);

          // only validate existence if present
          if(fromNode && !existingIds.has(fromNode)){
            unknownFrom.push({row: rowNum, id: fromNode});
            let low = fromNode.toLowerCase();
            if(idLowerMap[low] && idLowerMap[low] !== fromNode){
              caseSuggests.push({row: rowNum, typed: fromNode, suggestion: idLowerMap[low]});
            }
          }
          if(toNode && !existingIds.has(toNode)){
            unknownTo.push({row: rowNum, id: toNode});
            let low = toNode.toLowerCase();
            if(idLowerMap[low] && idLowerMap[low] !== toNode){
              caseSuggests.push({row: rowNum, typed: toNode, suggestion: idLowerMap[low]});
            }
          }

          // duplicates (use ASCII symbols to avoid Blogger encoding)
          let keyDir = `${fromNode}${MSG_ARROW}${toNode}`;
          if(seenDir.has(keyDir)){
            dupEdgeLines.push({row: rowNum, key: keyDir});
          }
          seenDir.add(keyDir);

          if(relation==="link"){
            let keyUndir = undirKey(fromNode, toNode);
            if(seenUndir.has(keyUndir)){
              bidirectionalDuplicates.push({row: rowNum, key: keyUndir});
            }
            seenUndir.add(keyUndir);
          }

          // self-loop
          if(fromNode && toNode && fromNode===toNode){
            selfLoops.push({row: rowNum, id: fromNode});
          }

          // Add edge (keeps your existing behavior)
          edges.add({
            id:"edge_"+fromNode+"_"+toNode+"_"+Math.random(),
            from:fromNode,
            to:toNode,
            arrows:(relation==="link"?"":"to"),
            color:colorE,
            originalColor:colorE,
            dashes:dashes,
            title:title,
            width: thickness,   
            length: length      
          });
        });

        // Error reporting for edges (ASCII-only display)
        if(missingFrom.length){
          addSummarizedListError("edges: missing 'from' value (rows)", missingFrom.map(r=>`${r}`));
        }
        if(missingTo.length){
          addSummarizedListError("edges: missing 'to' value (rows)", missingTo.map(r=>`${r}`));
        }
        if(unknownFrom.length){
          addSummarizedListError(
            "edges: 'from' references to non-existing nodes (rows)",
            unknownFrom.map(x=>`${x.row} ${MSG_ARROW} "${x.id}"`)
          );
        }
        if(unknownTo.length){
          addSummarizedListError(
            "edges: 'to' references to non-existing nodes (rows)",
            unknownTo.map(x=>`${x.row} ${MSG_ARROW} "${x.id}"`)
          );
        }
        if(caseSuggests.length){
          addSummarizedListError(
            "Case mismatch suggestions",
            caseSuggests.map(x=>`row ${x.row}: "${x.typed}" ${MSG_ARROW} maybe "${x.suggestion}"`)
          );
        }
        if(dupEdgeLines.length){
          addSummarizedListError(
            "Duplicate directed edges (rows)",
            dupEdgeLines.map(x=>`${x.row} ${MSG_ARROW} ${x.key}`)
          );
        }
        if(bidirectionalDuplicates.length){
          addSummarizedListError(
            "Duplicate 'link' edges detected (rows)",
            bidirectionalDuplicates.map(x=>`${x.row} ${MSG_ARROW} ${x.key}`)
          );
        }
        if(selfLoops.length){
          addSummarizedListError(
            "Self-loops detected (rows)",
            selfLoops.map(x=>`${x.row} ${MSG_ARROW} "${x.id}"`)
          );
        }
        if(unknownRelations.length){
          addSummarizedListError(
            "Unknown relation values (rows)",
            unknownRelations.map(x=>`${x.row} ${MSG_ARROW} "${x.value}"`)
          );
        }
        if(nonNumericVals.length){
          addSummarizedListError(
            "Non-numeric edge weights (rows)",
            nonNumericVals.map(x=>`${x.row} ${MSG_ARROW} "${x.value}"`)
          );
        }

        // Rebuild adjacencyList with directional edges
        nodes.forEach(n=>{
          adjacencyList[n.id]=[];
        });
        edges.forEach(e=>{
          let isLink=(e.originalColor==="black"||e.dashes===true);
          if(isLink){
            if(adjacencyList[e.from]) adjacencyList[e.from].push(e.to);
            if(adjacencyList[e.to])   adjacencyList[e.to].push(e.from);
          } else {
            // unidirectional
            if(adjacencyList[e.from]) adjacencyList[e.from].push(e.to);
          }
        });

        network.setData({nodes:nodes, edges:edges});
        renderGroupToggles();
        renderColorGradingToggles();

        // Kanban
        var kanbanIndexFound=(kanbanIndex>=0);
        if(kanbanIndexFound){
          let allK=new Set();
          nodes.forEach(n=>{
            if(n.kanbanValue) allK.add(n.kanbanValue);
          });
          kanbanValues=Array.from(allK).sort();
        } else {
          kanbanValues=[];
        }
        buildKanban();

        // Fill "From"/"To" dropdowns
        let fromSel=document.getElementById("pathFrom");
        let toSel = document.getElementById("pathTo");
        fromSel.innerHTML="";
        toSel.innerHTML="";
        let nodeArray=nodes.get();
        nodeArray.sort((a,b)=>(a.label||"").localeCompare(b.label||""));
        nodeArray.forEach(n=>{
          let optF=document.createElement("option");
          optF.value=n.id; optF.text=n.label||n.id;
          fromSel.appendChild(optF);

          let optT=document.createElement("option");
          optT.value=n.id; optT.text=n.label||n.id;
          toSel.appendChild(optT);
        });

        // Post-build checks: isolated nodes can hint at mismatched edges
        let degrees = {};
        nodes.forEach(n=>{
          degrees[n.id]=0;
        });
        edges.forEach(ed=>{
          if(degrees[ed.from]!==undefined) degrees[ed.from]++;
          if(degrees[ed.to]!==undefined) degrees[ed.to]++;
        });
        let isolated = Object.keys(degrees).filter(id=>degrees[id]===0);
        if(isolated.length){
          addSummarizedListError("Isolated nodes (degree = 0)", isolated.map(id=>nodes.get(id)?.label||id));
        }

      } catch(err){
        console.error(err);
        addErrorLine("Error processing Excel: " + err.message);
      }
    };
    reader.readAsBinaryString(blob);
  }

  document.addEventListener("DOMContentLoaded", async function(){
    document.getElementById("shareButton").addEventListener("click",function(){
      var dataURL=document.getElementById("dataURL").value.trim();
      var fullUrl = SITE_BASE_URL + '?sheetsUrl=' + encodeURIComponent(dataURL);
      navigator.clipboard.writeText(fullUrl).then(()=>alert("URL copied."));
    });

    let sheetsUrl=(new URLSearchParams(window.location.search)).get('sheetsUrl');
    let loadDataTriggered=false;
    if(sheetsUrl){
      document.getElementById("dataURL").value=decodeURIComponent(sheetsUrl);
      await loadDataFromURL();
      loadDataTriggered=true;
    } else {
      // Attempt to load previously used URL from localStorage if you want
      let savedURL=localStorage.getItem('dataURL');
      if(savedURL){
        document.getElementById("dataURL").value=savedURL;
        await loadDataFromURL();
        loadDataTriggered=true;
      }
    }
    if(!loadDataTriggered){
      await loadDefaultExcel();
    }
    loadFromStorage();
  });

  // Watermark inside network container
  var watermark=document.createElement('div');
  watermark.id='watermark';
  watermark.innerHTML=`<a href="https://github.com/andrefrsilva/sheets2network" target="_blank">Sheets2Network</a>`;
  document.getElementById("mynetwork").appendChild(watermark);
</script>
</body>
</html>
